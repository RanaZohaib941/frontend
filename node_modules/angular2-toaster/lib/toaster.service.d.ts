import { Toast, ToastType } from './toast';
import { IClearWrapper } from './clearWrapper';
import { Observable, Subject } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
export declare class ToasterService {
    addToast: Observable<Toast>;
    private _addToast;
    clearToasts: Observable<IClearWrapper>;
    private _clearToasts;
    removeToast: Observable<IClearWrapper>;
    /** @internal */
    _removeToastSubject: Subject<IClearWrapper>;
    /**
     * Creates an instance of ToasterService.
     */
    constructor();
    /**
     * Synchronously create and show a new toast instance.
     *
     * @param {(string | Toast)} type The type of the toast, or a Toast object.
     * @param {string=} title The toast title.
     * @param {string=} body The toast body.
     * @returns {Toast}
     *          The newly created Toast instance with a randomly generated GUID Id.
     */
    pop(type: ToastType | Toast, title?: string, body?: string): Toast;
    /**
     * Asynchronously create and show a new toast instance.
     *
     * @param {(string | Toast)} type The type of the toast, or a Toast object.
     * @param {string=} title The toast title.
     * @param {string=} body The toast body.
     * @returns {Observable<Toast>}
     *          A hot Observable that can be subscribed to in order to receive the Toast instance
     *          with a randomly generated GUID Id.
     */
    popAsync(type: ToastType | Toast, title?: string, body?: string): Observable<Toast>;
    /**
     * Clears a toast by toastId and/or toastContainerId.
     *
     * @param {string} toastId The toastId to clear.
     * @param {number=} toastContainerId
     *        The toastContainerId of the container to remove toasts from.
     */
    clear(toastId?: string, toastContainerId?: number): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ToasterService, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9hc3Rlci5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbInRvYXN0ZXIuc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRvYXN0LCBUb2FzdFR5cGUgfSBmcm9tICcuL3RvYXN0JztcbmltcG9ydCB7IElDbGVhcldyYXBwZXIgfSBmcm9tICcuL2NsZWFyV3JhcHBlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBUb2FzdGVyU2VydmljZSB7XG4gICAgYWRkVG9hc3Q6IE9ic2VydmFibGU8VG9hc3Q+O1xuICAgIHByaXZhdGUgX2FkZFRvYXN0O1xuICAgIGNsZWFyVG9hc3RzOiBPYnNlcnZhYmxlPElDbGVhcldyYXBwZXI+O1xuICAgIHByaXZhdGUgX2NsZWFyVG9hc3RzO1xuICAgIHJlbW92ZVRvYXN0OiBPYnNlcnZhYmxlPElDbGVhcldyYXBwZXI+O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVtb3ZlVG9hc3RTdWJqZWN0OiBTdWJqZWN0PElDbGVhcldyYXBwZXI+O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVG9hc3RlclNlcnZpY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKTtcbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91c2x5IGNyZWF0ZSBhbmQgc2hvdyBhIG5ldyB0b2FzdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KHN0cmluZyB8IFRvYXN0KX0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgdG9hc3QsIG9yIGEgVG9hc3Qgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gdGl0bGUgVGhlIHRvYXN0IHRpdGxlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYm9keSBUaGUgdG9hc3QgYm9keS5cbiAgICAgKiBAcmV0dXJucyB7VG9hc3R9XG4gICAgICogICAgICAgICAgVGhlIG5ld2x5IGNyZWF0ZWQgVG9hc3QgaW5zdGFuY2Ugd2l0aCBhIHJhbmRvbWx5IGdlbmVyYXRlZCBHVUlEIElkLlxuICAgICAqL1xuICAgIHBvcCh0eXBlOiBUb2FzdFR5cGUgfCBUb2FzdCwgdGl0bGU/OiBzdHJpbmcsIGJvZHk/OiBzdHJpbmcpOiBUb2FzdDtcbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSBjcmVhdGUgYW5kIHNob3cgYSBuZXcgdG9hc3QgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmcgfCBUb2FzdCl9IHR5cGUgVGhlIHR5cGUgb2YgdGhlIHRvYXN0LCBvciBhIFRvYXN0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHRpdGxlIFRoZSB0b2FzdCB0aXRsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJvZHkgVGhlIHRvYXN0IGJvZHkuXG4gICAgICogQHJldHVybnMge09ic2VydmFibGU8VG9hc3Q+fVxuICAgICAqICAgICAgICAgIEEgaG90IE9ic2VydmFibGUgdGhhdCBjYW4gYmUgc3Vic2NyaWJlZCB0byBpbiBvcmRlciB0byByZWNlaXZlIHRoZSBUb2FzdCBpbnN0YW5jZVxuICAgICAqICAgICAgICAgIHdpdGggYSByYW5kb21seSBnZW5lcmF0ZWQgR1VJRCBJZC5cbiAgICAgKi9cbiAgICBwb3BBc3luYyh0eXBlOiBUb2FzdFR5cGUgfCBUb2FzdCwgdGl0bGU/OiBzdHJpbmcsIGJvZHk/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFRvYXN0PjtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYSB0b2FzdCBieSB0b2FzdElkIGFuZC9vciB0b2FzdENvbnRhaW5lcklkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRvYXN0SWQgVGhlIHRvYXN0SWQgdG8gY2xlYXIuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSB0b2FzdENvbnRhaW5lcklkXG4gICAgICogICAgICAgIFRoZSB0b2FzdENvbnRhaW5lcklkIG9mIHRoZSBjb250YWluZXIgdG8gcmVtb3ZlIHRvYXN0cyBmcm9tLlxuICAgICAqL1xuICAgIGNsZWFyKHRvYXN0SWQ/OiBzdHJpbmcsIHRvYXN0Q29udGFpbmVySWQ/OiBudW1iZXIpOiB2b2lkO1xufVxuIl19